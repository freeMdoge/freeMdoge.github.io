[{"content":"相关视频 【游戏开发】新人如何用unity做出第一个属于自己的游戏Demo\n该视频发布于5年前的2020年\nC# 书籍：Visual C# 从入门到精通（第8版），深入理解C#（第3版），CLR via C#（第4版）\nUnity 中文文档：docs.unity.cn/cn\nUnity Learn：learn.unity.com\nup主推荐：BeaverJoe，M_Studio，Shallot夏洛特，鱼一元001\n【Unity零基础入门教程 】前十个游戏都是垃圾 - 生存射击（2/9）\n3D 游戏，共 26p，大概 20min/p\nup主主页：丑萌气质狗\nUnity小白超神系列教程：Flappy Bird\n总时长 1:17:46 。合集中还有其他短时间小游戏制作教程（打砖块，气球大战，对话框）\n这是全B站最还原的FlappyBird飞翔的小鸟！FlappyBird开发教学合集！Unity3d基础教学、代码入门，教你做游戏！\n打算看这个来回忆操作，共 11p，20~30min/p\n手把手教你用Unity3D制作【FlappyBird】简单易学 | 简单入门游戏制作（零基础入门教程/Unity2D/3D/游戏开发/超详细）B0102\n2021年视频，相对比较新，但看着像卖课，最后没有打算看这个。9p，10min/p\n以下使用 BV1jK411V7V7 （这是全B站最还原的FlappyBird飞翔的小鸟！FlappyBird开发教学合集！Unity3d基础教学、代码入门，教你做游戏！）作为教程\n涉及知识点 对 GameObject 的基本操作：\n1 2 3 4 5 6 7 8 9 10 11 // get component/GameObject Rigidbody2D rb = getComponent\u0026lt;Rigidbody2D\u0026gt;(); public Rigidbody2D rb; // +编辑器内拖动 Rigidbody2D rb = this.getComponent\u0026lt;Rigidbody2D\u0026gt;(); Rigidbody2D rb = tut.getComponent\u0026lt;Rigidbody2D\u0026gt;(); // 获取其他GameObject的Component，tut是一个GameObject GameObject tut = GameObject.Find(\u0026#34;tut\u0026#34;); // transform transform.postion = new Vector3(transform.position.x, transform.position.y+0.2f, transform.position.z); transform.Translate(0, 0.2f, 0); // rigidbody rigidbody2D.velocity = new Vector2(0, 8); 为什么把鸟的图片放在它的子物体上？\n为了将图片渲染和物理计算分开来，旋转图片时不至于把碰撞箱之类的一起转了导致受力发生变化 UI的动画用到了一个插件 DOTween （免费版），可以在 Asset Store 里 import\n1 2 3 4 5 6 7 8 9 using DG.Tweening; public void HideUI() { //给canvasGroup添加一个渐变，并且在渐变之后隐藏GameObject canvasGroup.DOFade(0, time).onComplete = ()=\u0026gt; { gameObject.SetActive(false); } } Prefab 的实例化：\n1 GameObject pb = GameObject.Instantiate(myPrefab, parentGO); 使用协程实现等待执行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public void Start() { StartCoroutine(SpawnGO()); } private IEnumerator SpawnGO() { while (true) { yield return new WaitForSeconds(2f); SpawnOneGO(); } } 碰撞箱/触发器的碰撞判断：\n1 2 private void OnCollisionEnter2D(Collision2D collision) {} private void OnTriggerEnter2D(Collider2D collision) {} // isTrigger 注意：这里是判断与挂载的 GameObject 下的任意 Collision / Rigidbody 碰撞，如果要实现每个 Collision 碰撞触发不同效果需要加子 GameObject 与 UI 相关的组件在 UnityEngine.UI 命名空间下：\n1 using UnityEngine.UI; 整形与字符串的转换：\n1 2 int.Parse(str); // string to int num.ToString(); // int to string 生成随机数：\n1 float r = Random.Range(-1.5f, 2.7f); UnityEngine.Random 场景转换：\n1 2 using UnityEngine.SceneManagement; SceneManager.LoadScene(\u0026#34;GameScene\u0026#34;); 要在 Build Settings 里面 Add Open Scenes 把场景给构建一下 利用 PlayerPrefs 实现简单的数据持久存储：\n1 2 PlayerPrefs.SetInt(\u0026#34;dataName\u0026#34;, num); int x = PlayerPrefs.GetInt(\u0026#34;dataName\u0026#34;); Deepseek：数据会保存在设备上，即使游戏关闭后仍然存在。Windows 下存储位置：注册表 (HKCU\\Software[公司名][产品名]) 额外知识点 遍历子物体：\n1 2 3 4 5 foreach (Transform child in transform) { Background bg = child.GetComponent\u0026lt;Background\u0026gt;(); // ... } 不包括自身与孙子物体 内容 流程 主界面：LOGO，鸟上下飞，Play按钮 教程：显示教程和分数，点击开始，鸟径直飞 游戏：点击飞行，生成柱子，碰撞检测 结束：显示分数和奖牌，Restart按钮 Game管理器：控制流程 记录状态：isReady, isPlaying 流程切换：进入教程，游戏开始，游戏结束 记录分数 角色：动画，飞行操作，角度摆动 背景：背景后移，拼接 背景管理器：管理多个背景的移动 UI：分数，LOGO，教程，结束页面 UI工具：初始化UI，控制UI显示渐变 柱子：生成（随机高度），移动，碰撞检测，自动销毁 柱子管理器：定时生成柱子，控制所有柱子移动， 碰撞检测：失败碰撞箱和加分碰撞箱 游戏结束：所有动画停止，记录BestScore，显示结束UI，两个分数，奖牌，Restart 分数：记录分数 ","date":"2025-07-25T07:55:48+08:00","image":"https://freeMdoge.github.io/p/unityflappy-bird-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/fengmian_hu_362a221d3f073363.png","permalink":"https://freeMdoge.github.io/p/unityflappy-bird-%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/","title":"【Unity】Flappy Bird 开发笔记"},{"content":"CS 61A Test the code in HW/Lab use ok:\n1 py ok --local -q \u0026lt;question_name\u0026gt; use ok interactively:\n1 py ok --local -q \u0026lt;question_name\u0026gt; -i use Python\u0026rsquo;s doctest:\n1 py -m doctest \u0026lt;file_name.py\u0026gt; Lecture 01 Welcome Python code consists of expressions and statements\nStatements typically describe actions.\nassignment statement expressions typically describe computations.\na number numbers combined with mathematical operators a compound expression the interperter will evaluate（求值） using infix notation call expression applying a function to some arguments Operator(Operand, Operand) Function notation has three principal advantages over the mathematical convention of infix notation: arbitrary number of arguments a straightforward way to nested expressions simple forms (without square root, superscripts, \u0026hellip;) Python 代码由 expressions 和 statements 两部分组成。statements 用于描述 actions ，比如赋值；expressions 用于描述 computations ，比如数字，计算表达式，函数调用表达式。\n函数表示相较传统的中序表达式，有一系列的优点。\nLecture 02 Functions built-in functions and built-in names\nassignment statement\nname = expression python will evaluate the expression and bind it to the name it\u0026rsquo;s possible to bing mutiple names to values in one single statement assignment statements can also be used to give names to functions Defining Functions\ndef statement \u0026amp; return expression the top line between the def and the colon is called the function signature ( \u0026lt;name\u0026gt; (\u0026lt;formal parameters\u0026gt;) ) the function body is everything that\u0026rsquo;s indented after the first line execution procesure for def statement: create a funtion with signature set the body of that funtion bind \u0026lt;name\u0026gt; to that function in the current frame procedure for calling/applying user-defined funtions (ver 1): Add a local frame, forming a new environment Bind the function\u0026rsquo;s formal parameters to its arguments in that frame execute the body of the funtion in that new environment Environment\nLooking Up Names In Environments An environment is a sequence of frames A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found Environment Diagrams Environments are real things. They\u0026rsquo;re the way in which an interpreter for a programming language keeps track of what names mean assignments statements change the bindings between names and values in frames Print and None\nNone indicates that nothing is returned. A funtions that does not explicitly return a value will return None. None is not displayed by the interpreter as the value of an expression Pure Funtions just return values; Non-Pure Functions have side effect 在 Python 中，assignment statements 用于给 names 绑定值。\ndef 语句可以用来定义函数，它包括 function signature 和 function body ，并且 def 语句会将 signature 中的 name 在当前帧上绑定在定义的函数上。调用函数时会建立一个新的 frame，将参数传入新的 frame 中，在里面执行函数的 body 。\nFormal parameter 是形参，argument 是实参\n一系列的 frame 构成 environment，environment 用于确定 name 指代了什么。寻找一个 name 的意义时，会找到最近的出现该 name 的 frame 中的值。\n如果一个函数什么都不返回，那么它会返回 None\nLecture 03 Control Environment\nPython features\noperators 2013 / 10 =\u0026gt; 201.3 (truediv), 2013 // 10 =\u0026gt; 201 (floordiv) from operator import add, mul, truediv, floordiv, mod assignment statement (muliple values) return n // d, n % d q, r = func(2013, 10) documentation and doctest doc string: the first line below the def line in the def statement example interactive session: can be simulated by \u0026ldquo;py -m doctest \u0026lt;filename\u0026gt;\u0026rdquo; \u0026ldquo;py -m doctest -v \u0026lt;filename\u0026gt;\u0026rdquo; will show details default values def func(n, d=10) Conditional Statements\nCompound Statements Clause: Header + indented statements those indented statements are called the Suite of the clause The first header determines a statement\u0026rsquo;s type, the header of a clause \u0026ldquo;controls\u0026rdquo; the suite that follows (eg. def statement) if, elif, else Boolean Contexts False values: False, 0, \u0026lsquo;\u0026rsquo;, None True values: Anything else (True) Iteration\nwhile statements evaluate the header\u0026rsquo;s expression, if true, then execute the suite 代码执行时，会在被执行代码的 environment 中寻找 name 的意义\nPython 有一些特性：运算符、多元素的赋值、doctest、函数参数的默认值\n复合语句总是由一系列 clause 组成，每个 clause 中先是一个 header ，然后是冒号，然后一系列缩进的 statement\nPython 中的 False 可以是 False, 0, 空字符串, None 等，其他值都是 True\nLecture 04 High-Order Functions The Fibonacci Sequnce\nControl\nThe Condition Statements can skip clause, but the Call Expression will evaluate all of the subexpressions Control Expressions\nshort-circuiting and: evaluate the \u0026lt;left\u0026gt; first, if true, then evaluate the \u0026lt;right\u0026gt; or: evaluate the \u0026lt;left\u0026gt; first, if false, then evaluate the \u0026lt;right\u0026gt; Higher-Order Functions\nto generalize patterns by defining functions that take arguments, that give us back the specific instances of those patterns a formal parameter can be bound to a function a function can be the return value Functions defined within other function bodies are bound to names in a local frame a local def statement can refer to names in the enclosing function The Purpose of Higher-Order Functions Functions are first class: Functions can be manipulated as values in Python, meaning they can be passed as arguments, they can be returned as returned values. Higher-order functions: Express general methods of computation, Remove repetition from programs, Separate concerns among functions assert statement assert \u0026lt;boolean expression\u0026gt;, \u0026lt;error message\u0026gt; if the expression evaluates to a false value, then the error message will be printed. 1 2 3 4 5 6 def make_adder(n): \u0026#39;\u0026#39;\u0026#39; A function that returns a function \u0026#39;\u0026#39;\u0026#39; def adder(k): return k + n return adder 前面的 Fibonacci Sequence 和 Control Statements 与 Call Expressions 之间的比较是为了深化对控制语句的理解\nPython 中的 and 和 or 有短路逻辑\nHigher-Order Functions 可以通过定义接收参数的函数来概括模式，从而返回这些模式的具体实例。函数可以作为参数，也可以作为返回值。函数是第一类值\n定义在其他函数之中的函数可以引用它所在函数的 name，内层函数本身会绑定到外层函数所在 local frame 的 name 上\nassert statements 可以用来报错，当它后面的表达式为假时，打印错误信息\nLecture 05 Environments Environments\nEnvironments Enable Higher_Order Functions\nHigher-order function: A function that takes a funtion as an argument value or returns a funtion as a return value\nApplying a user-defined function:\ncreate a new frame bind formal parameters to arguments execute the body Environment Diagrams for Nested Def Statements\nEvery user-defined function has a parent frame (often global) The parent of a function is the frame in which it was defined Every local frame has a parent frame (often global) The parent of a frame is the parent of the function called How to Draw an Environment Diagram\nLocal Names\nLocal Name are not Visible to Other (Non-Nested) Functions Lambda Expressions\nNo \u0026ldquo;return\u0026rdquo; keyword in lambda expressions! must be a single expression (and Lambda expressions in Python cannot contain statements at all) Lambda expressions are not common in Python, but important in general 1 2 3 4 square = lambda x: x * x print(square(10)) print((lambda x: x * x)(9)) Fuction Currying\nTransforming a multi-argument function into a single-argument, higher-order function 对于普通的函数，它在环境图中的 parent 就是 Global（这表示它们是在 Global frame 中被 define 的），而对于嵌套的内层函数，它的 parent 是它的外层函数被调用时创建的 frame（它们是在外层函数所在的 frame 中被 define 的）\nLambda 表达式中只能放 expression ，不能放 statement 。Lambda 表达式和 def 语句会按照相同的行为创建函数（决定函数的 behavior, parent 等），但是 def 语句会给函数一个 intrinsic name 而 Lambda 表达式不会\n柯里化（Currying）是一种处理多元函数的方法。它产生一系列连锁函数，其中每个函数固定部分参数，并返回一个新函数，用于传回其它剩余参数的功能。（转自网络）\nLecture 06 Sounds (Optional) Why do we use higher-order functions\nExample: WAV files Lecture 07 Functional Abstraction Lambda Function Environments\nReturn Statements\ninverse The inverse of a function is to return a g() such that it\u0026rsquo;s the case that f(x) passed into g gives us back x 1 2 3 4 5 6 7 8 9 10 11 def search(f): \u0026#34;\u0026#34;\u0026#34;Return the first positive integer x that makes f(x) equals to True\u0026#34;\u0026#34;\u0026#34; x = 0 while True: if f(x): return x x += 1 def inverse(f): \u0026#34;\u0026#34;\u0026#34;Return g(y) such that g(f(x)) = x.\u0026#34;\u0026#34;\u0026#34; return lambda y: search(lambda x: f(x) == y) Abstraction\nFunction Abstraction Choosing Name Which Values Deserve a Name Repeated compound expressions Meaningful parts of complex expressions Errors \u0026amp; Traceback\nsyntax error, runtime error, logical error traceback inverse 表示反函数\n编写代码有三种 error，其中 runtime error 会有 traceback 可以参考\nLecture 08 Function Examples Decorators\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def trace(fn): \u0026#34;\u0026#34;\u0026#34; Return a function. Why do we use a function to return a function, rather than directly using one function? That is because we need the outer function to receive a parameter, which decide which function the inner function will call In other word, what we need is not a fixed function, but a function that would flexibly call the function we want. So we need a outer function to program the inner function. \u0026#34;\u0026#34;\u0026#34; def traced(x): \u0026#34;\u0026#34;\u0026#34; This function does what you want the decorator to do. Call print before fn, then call fn, then pass what fn returned. What is fn? The outer funtion will told. \u0026#34;\u0026#34;\u0026#34; print(\u0026#39;Calling\u0026#39;, fn, \u0026#39;on argument\u0026#39;, x) return fn(x) return traced @trace def square(x): return x * x # is identical to : # square = trace(square) def sum_squares_up_to(n): k = 1 total = 0 while k \u0026lt;= n: total, k = total + square(k), k + 1 return total 1 2 3 4 5 6 7 8 9 10 def erasefunc(f): def tmp(x, y): return 1 return tmp @erasefunc def square(x): return x * x print(square(10, 9)) decorator 感觉可以理解为外层函数接收需要被装饰的函数 f ，返回的内层函数负责调用 f ，并额外进行一些操作，看作是装饰。\nLecture 09 Recursion Self-Reference\nReturn a function by its own name 1 2 3 4 5 6 7 8 9 10 11 12 13 def print_all(x): print(x) return print_all print_all(1)(3)(5) def print_sums(x): print(x) def next_sum(y): return print_sums(x+y) return next_sum print_sums(1)(3)(5) Recursive Functions\nConditional statements check for base cases Base cases are evaluated without recursive calls Recursive cases are evaluated with recursive calls Mutual Recursion\noccurs when two different functions call each other Recursion and Iteration\nConverting Recursion to Iteration: Figure out what state must be maintained by the iterative funciton Lecture 10 Tree Recursion 本节通过 打印右凸三角阶梯型数字、打印右凹阶梯型数字、求斐波那契数列、解决整数划分问题 来加深对递归的理解。\n整数划分：给定 $n, m$ ，使用不超过 $m$ 的若干可重复正整数相加得到 $n$ ，共有多少种情况？\n分析：两种情况，使用至少一次 $m$，和不使用 $m$，即 $f_{n,m} = f_{n-m,m} + f_{n,m-1}$ ，递归求解\nLecture 11 Sequences Lists\n基本用法 1 2 3 4 odds = [41, 43, 47, 49] odds[2] # odds[2] =\u0026gt; 47 getitem(odds, 0) # getitem(odds, 0) =\u0026gt; odds[0] =\u0026gt; 41 (getitem在operator模块中) len(odds) # len(odds) =\u0026gt; 4 列表的合并和重复 1 2 3 digits = [1, 8, 2, 8] [2, 7] + digits * 2 # =\u0026gt; [2, 7, 1, 8, 2, 8, 1, 8, 2, 8] 列表嵌套 1 myList = [[10, 20], [30, 40]] 查 1 2 3 4 digits = [1, 8, 2, 8] 1 in digits # =\u0026gt; True 5 not in digits # =\u0026gt; True [1, 8] in digits # =\u0026gt; False For Statements\n1 2 for \u0026lt;name\u0026gt; in \u0026lt;expression\u0026gt;: \u0026lt;suite\u0026gt; the header \u0026lt;expression\u0026gt; must yield an iterable value (a sequence) Sequence Unpacking: 1 2 3 pairs = [[1, 2], [2, 2], [3, 2]] for x, y in pairs: # ... Range\nA range is a sequence of consecutive integers 1 2 range(-2, 2) # =\u0026gt; -2, -1, 0, 1 range(4) # =\u0026gt; 0, 1, 2, 3 Convert to a list (List constructor) 1 list(range(-2, 2)) # =\u0026gt; [-2, -1, 0, 1] for _ in range 1 2 for _ in range(3): print(\u0026#39;Go Bears!\u0026#39;) List Comprehensions\n1 2 3 4 5 6 7 8 9 10 letters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;p\u0026#39;] [letters[i] for i in [3, 4, 6, 8]] # =\u0026gt; [\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;o\u0026#39;] odds = [1, 3, 5, 7, 9] [x+1 for x in odds] # =\u0026gt; [2, 4, 6, 8, 10] [x for x in odds if 25 % x == 0] # =\u0026gt; [1, 5] Lecture 12 Containers Closure Property of Data Types\nThe result of combination can itself be combined using the same method (Lists can contain lists as elements) Slicing\nslicing operator: [:] 1 2 3 4 5 odds = [3, 5, 7, 9, 11] odds[1:3] # =\u0026gt; [5, 7] odds[:3] # =\u0026gt;[3, 5, 7] odds[1:] # =\u0026gt; [5, 7, 9, 11] odds[:] # =\u0026gt; [3, 5, 7, 9, 11] slicing creates new values Processing Container Values\nSequence Aggregation Several built-in functions take iterable arguments and aggregate them into a value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 sum(iterable[, start]) -\u0026gt; value # \u0026#34;iterable\u0026#34; can be a list # \u0026#34;[]\u0026#34; means optional # return the sum of an iterable of numbers plus the value of parameter \u0026#39;start\u0026#39; (the default value of \u0026#39;start\u0026#39; is 0, which means if the members of \u0026#39;iterable\u0026#39; are lists, you need to explicitly provide that \u0026#39;start\u0026#39; is \u0026#39;[]\u0026#39; (empty list), or it will throw an error) # if you sum a list of lists, you get a list containing the elements of those lists. # sum([ [1], [2, 3], [4] ], []) =\u0026gt; [1, 2, 3, 4] # sum([ [[1]], [2] ], []) =\u0026gt; [[1], 2] max(iterable[, key=func]) -\u0026gt; value max(a, b, c, ...[, key=func]) -\u0026gt; value # return the largest argument # key function: applies a function to every element and computes the maximum based on the return values (notice: the return value of max() is x, not f(x)!) min() all(iterable) -\u0026gt; bool # Return True if bool(x) if True for all values x in the iterable. # If the iterable is empty, return True any() Strings\n1 2 3 4 5 6 \u0026#39;nihao\u0026#39; # 这样表示的字符串中不能有单引号 \u0026#34;nihao\u0026#34; \u0026#34;\u0026#34;\u0026#34; multiple lins string the second line \u0026#34;\u0026#34;\u0026#34; # 三引号的字符串可以写多行 \u0026#39;line1\\nline2\u0026#39; # \\n 换行 1 2 3 4 city = \u0026#39;Berkeley\u0026#39; len(city) # =\u0026gt; 8 city[3] # =\u0026gt; \u0026#39;k\u0026#39; (returns a string) \u0026#39;here\u0026#39; in \u0026#34;where\u0026#39;s Waldo?\u0026#34; # =\u0026gt; True Dictionaries\n1 2 3 4 5 6 {} # empty dictionary numerals = {\u0026#39;I\u0026#39;: 1, \u0026#39;V\u0026#39;: 5, \u0026#39;X\u0026#39;: 10} numerals[\u0026#39;X\u0026#39;] # =\u0026gt; 10 list(numerals) # =\u0026gt; [\u0026#39;I\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;X\u0026#39;] numerals.values() # =\u0026gt; dict_values([1, 5, 10]) list(numerals.values()) # =\u0026gt; [1, 5, 10] A key of a dictionary cannot be a list or a dictionary (or any mutable type) Dictionary Comprehension 1 {\u0026lt;key exp\u0026gt;: \u0026lt;value exp\u0026gt; for \u0026lt;name\u0026gt; in \u0026lt;iter exp\u0026gt; if \u0026lt;filter exp\u0026gt;} 1 {x * x: x for x in [1, 2, 3, 4, 5] if x \u0026gt; 2} # =\u0026gt; {9: 3, 16: 4, 25: 5} Lecture 13 Data Abstraction Data Abstraction: Rational Numbers\nconstructor selector Abstraction Barriers\nPair\n1 2 pair = [1, 2] x, y = pair # x = 1, y = 2 Data Representations\n主要讲数据封装抽象的思想\nLecture 14 Trees Tree Abstraction\nRecursive description A tree has a root label and a list of branched Each branch is a tree A tree with zero branches is called a leaf Relative description Each location in a tree is called a node Each node has a label that can be any value One node can be the parent/child of another Implementing the Tree Abstraction\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def tree(label, branches = []): for branch in branches: assert is_tree(branch), \u0026#39;branched must be trees\u0026#39; return [label] + list(branches) def label(tree): return tree[0] def branches(tree): return tree[1:] def is_tree(tree): if type(tree) != list or len(tree) \u0026lt; 1: return False for branch in branches(tree): if not is_tree(branch): return False return True def is_leaf(tree): return not branches(tree) def count_leaves(t): if is_leaf(t): return 1 else: branch_counts = [count_leaves(b) for b in branches(t)] return sum(branch_counts) def leaves(tree): if is_leaf(tree): return [label(tree)] else: return sum(leaves(b) for b in branches(tree)) def increment_leaves(t): if is_leaf(t): return tree(label(t) + 1) else: bs = [increment_leaves(b) for b in branches(t)] return tree(label(t), bs) def increment(t): return tree(label(t) + 1, [increment(b) for b in branches(t)]) Lecture 15 Mutability Object\nA type of object is called a class; classes are first-class values in Python Object-oriented programming: A metaphor for organizing large programs Special syntax that can improve the composition of programs In Python, every value is an object All objects have attributes A lot of data manipulation happens through object methods String (example)\nRepresenting ASCII Unicode Mutation Operations\nmutation is a word that\u0026rsquo;s used whenever there\u0026rsquo;s a change to an object All names that refer to the same object are affected by a mutation Only objects of mutable types can change: lists \u0026amp; dictionaries Tuples\nAnything separated by commas is evaluated as a tuple A lot of people always put the parentheses around them just to be clear about what\u0026rsquo;s going on 1 2 3 4 5 6 3, 4, 5, 6 # =\u0026gt; (3, 4, 5, 6) () # empty tuple tuple([3, 4, 5]) # =\u0026gt; (3, 4, 5) 2, # =\u0026gt; (2,) (a tuple with only one element) (3, 4) + (5, 6) # =\u0026gt; (3, 4, 5, 6) 5 in (3, 4, 5) # =\u0026gt; True Tuples are immutable values that means it is possible to use them as the keys in a dictionary (it is not allowed to use a list as a key in a dictionary or you will get the error \u0026ldquo;unhashable type list\u0026rdquo;) Immutable values are protected from mutation A immutable sequence may still change if it contains a mutable value as an element Mutation\nIdentity Operators Identity: \u0026lt;exp0\u0026gt; is \u0026lt;exp1\u0026gt; evaluates to True if both \u0026lt;exp0\u0026gt; and \u0026lt;exp1\u0026gt; evaluate to the same object Equality: \u0026lt;exp0\u0026gt; == \u0026lt;exp1\u0026gt; evaluates to True if both \u0026lt;exp0\u0026gt; and \u0026lt;exp1\u0026gt; evaluate to equal values Identical objects are always equal values, but not the other way around A default argument value is part of a function value, not generated by a call Mutable Functions\n实现函数中持久存储数据：在外层函数中用列表存要存储的数据，在内层函数实现修改，然后返回内层函数\nLecture 16 Iterators Iterators\nA container can provide an iterator that provides access to its elements in some order built-in function: iter(iterable) Return an iterator over the elements of an iterable value built-in function: next(iterator) Return the next element in an iterator The iterator will move advanced at the same time An iterable value is any value that can be passed to iter to produce an iterator An iterator value is returned from iter and can be passed to next; all iterators are mutable 1 2 3 4 5 s = [[1, 2], 3, 4, 5] t = iter(s) next(t) # =\u0026gt; [1, 2] next(t) # =\u0026gt; 3 list(t) # =\u0026gt; [4, 5] Dictionary Iteration\nThe order of items in a dictionary is the order in which they were added (starting at Python 3.6. In older versions, items in a dictionary appeared in an arbitrary order) 1 2 3 4 d = {\u0026#39;o\u0026#39;: 1, \u0026#39;t\u0026#39;: 2} k = iter(d.keys()) v = iter(d.values()) i = iter(d.items()) If the dictionary changes size, then we can\u0026rsquo;t use any of the iterators we\u0026rsquo;ve constructed For Statements\n1 2 3 4 5 6 7 r = range(3, 6) ri = iter(r) next(ri) for i in ri: print(i) # =\u0026gt; 4 \\n 5 for i in ri: print(i) # =\u0026gt; nothing, because we\u0026#39;re already at the end of ri Built-In Iterator Functions\nMany built-in Python sequence operations return iterators that compute results lazily (lazily computation: only computed when it has been requested)\nmap(func, iterable) Iterate over func(x) for x in iterable\napplies the func to each element in the iterable instead of applying it immediately, it returns and iterator, which iterates over the values func(x) for every x in the iterable filter(func, iterable) Iterate over x in iterable if func(x)\nzip(first_iter, second_iter) Iterate over co-indexed (x, y) pairs\nreversed(sequence) Iterate over x in a sequence in reverse order\nTo view the contents of an iterator, place the resulting elements into a container\nlist(iterable) tuple(iterable) sorted(iterable) Created a sorted list Zip\n1 2 3 4 5 6 7 8 9 10 11 # returns an iterator over co-indexed tuples list(zip([1, 2], [3, 4])) # =\u0026gt; [(1, 3), (2, 4)] # if one iterable is longer than the other, zip only iterates over matches and skips extras list(zip([1, 2], [3, 4, 5])) # =\u0026gt; [(1, 3), (2, 4)] # more than two iterables can be passed to zip list(zip([1, 2], [3, 4, 5], [6, 7])) # =\u0026gt; [(1, 3, 6), (2, 4, 7)] Using Iterators\nReasons for Using Iterators Code that processes and iterator or iterable makes few assumptions about the data itself that means Changing the data representation from a list to a tuple,map object, or dict_keys doesn\u0026rsquo;t require rewriting code. An iterator bundles together a sequence and a position within that sequence as one object Lecture 17 Generators Generators\nA generator function is a function that yields values instead of returning them A normal function returns once; a generator function can yield multiple times A generator is an iterator created automatically by calling a generator function When a generator function is called, it returns a generator that iterates over its yields Generators \u0026amp; Iterators\nA yield from statement yields all values from an iterator or iterable (Python 3.3) 1 2 3 4 5 6 7 8 9 10 def a_then_b_1(a, b): for x in a: yield x for x in b: yield x def a_then_b_2(a, b): yield from a yield from b # a_then_b_1 and a_then_b_2 are completely equivalent If you\u0026rsquo;re ever writing a program there there are many possibilities and you only want a few of them, sometimes this generator function approach can not only be easier to write, easier to read, but also deamatically faster to run Lecture 18 Objects Object-Oriented Programming\nClass Statements\n1 2 3 4 5 6 7 8 9 10 class Account: # __init__ is a special method name for the function that constructs an Accoount instance def __init__(self, account_holder): self.balance = 0 self.holder = account_holder # self is the instance of the Account class on which deposit() was invoked: a.deposit(10) def deposit(self, amount): self.balance = self.balance + amount return self.balance Creating Instances\nthe __init__ method is sometimes called a constructor Instance Attributes An object\u0026rsquo;s attributes are accessed and modified using dot expressions Any attribute can be assigned any value it\u0026rsquo;s OK to introduce a new attribute that wasn\u0026rsquo;t named before. A new attribute can be added at any time in Python Methods\nAll invoke methods have access to the object via the self parameter, and so they can all sccess and manipulate the object\u0026rsquo;s attributes the dot notation automatically supplies the first argument (self) Lecture 19 Attributes Class Attributes\nAssignment \u0026amp; def statements in the suite of class statement create attributes of the class 1 2 3 4 5 6 7 class Clown: nose = \u0026#39;big and red\u0026#39; def dance(): return \u0026#39;No thanks\u0026#39; Clown.nose # =\u0026gt; \u0026#39;big and red\u0026#39; Clown.dance() # =\u0026gt; \u0026#39;No thanks\u0026#39; 1 2 3 4 5 class Account: interest = 0.02 tom_account = Account() tom_account.interest # =\u0026gt; 0.02 Attribute Lookup\nWhen evaluete a dot expression, the name will be matched against the instance attributes of that object, then the class attribute value getattr(instance, attribute_name) look up an attribute using a string (attribute_name) hasattr(instance, attribute_name) whether an attribute of this name exists Attribute Assignment\nif the object is an instance, then assignment sets an instance attribute if the object is a class, then assignment sets a class attribute 1 2 3 4 5 6 7 class Account: interest = 0.02 tom_account = Account() # this is attribute assignment that adds the attribute named interest to the Tom account, not modifies the attribute in Account class: tom_account.interest = 0.08 Method Calls\nBound Methods\nObject + Function = Bound Method 1 2 3 # there are two different ways to call method: Account.deposit(tom_account, 1001) tom_account.deposit(1007) Lecture 20 Inheritance Inheritance\n1 2 class \u0026lt;name\u0026gt;(\u0026lt;base class\u0026gt;): \u0026lt;suite\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Account: interest = 0.02 def __init__(self, account_holder): self.balance = 0 self.holder = account_holder def deposit(self, amount): self.balance = self.balance + amount return self.balance def withdraw(self, amount): if amount \u0026gt; self.balance: return \u0026#39;Insufficient funds\u0026#39; self.balance = self.balance - amount return self.balance class CheckingAccount(Account): withdraw_fee = 1 interest = 0.01 def withdraw(self, amount): return Account.withdraw(self, amount + self.withdraw_fee) Looking up attribute names on classes if it names an attribute in the class, return the attribute value otherwise, look up the name in the base class, if there is one Object-Oriented Design\nDesigning for Inheritance Inheritance and Composition Inheritance: \u0026ldquo;is a\u0026rdquo;, Composition: \u0026ldquo;has a\u0026rdquo; Multiple Inheritance\n1 2 class AsSeenOnTVAccount(CheckingAccount, SavingsAccount): # ... Lecture 21 Representation String Representations\nIn Python, all objects produce two string representations The str is legible to humans The repr is legible to the Python interpreter The str and repr strings are often the same, but not always repr(object) return the canonical string representation of the object. For most object types, eval(repr(object)) == object The result of calling repr on a value is what Python prints in an interactive session Some objects do not have a simple Python-readable string 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; 12e12 12000000000000.0 \u0026gt;\u0026gt;\u0026gt; repr(min) \u0026#39;\u0026lt;built-in function min\u0026gt;\u0026#39; # do not have a simple Python-readable string The result of calling str on the value of an expression is what Python prints using the print function 1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; from fractions import Fraction \u0026gt;\u0026gt;\u0026gt; half = Fraction(1, 2) \u0026gt;\u0026gt;\u0026gt; repr(half) \u0026#39;Fraction(1, 2)\u0026#39; \u0026gt;\u0026gt;\u0026gt; str(half) \u0026#39;1/2\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(half) 1/2 \u0026gt;\u0026gt;\u0026gt; eval(repr(half)) Fraction(1, 2) \u0026gt;\u0026gt;\u0026gt; eval(str(half)) 0.5 F-Strings\nString interpolation involves evaluating a string literal that contains expressions The result of evaluating an f-string literal contains the str string of the value of each sub-expression. Sub-expressions are evaluated in the current environment 1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; f\u0026#39;2 + 2 = {abs(2 + 2)}\u0026#39; \u0026#39;2 + 2 = 4\u0026#39; \u0026gt;\u0026gt;\u0026gt; s = [9, 8, 7] \u0026gt;\u0026gt;\u0026gt; f\u0026#39;{s.pop()} {s.pop()} {s}.\u0026#39; \u0026#39;7 8 [9]\u0026#39; 1 \u0026#39;Ratio({0}, {1})\u0026#39;.format(numer, denom) Polymorphic Function\nstr and repr are both polymorphic; they apply to any object repr invokes a zero-argument method __repr__ on its argument str invokes a zero-argument method __str__ on its argument 1 str(half) == half.__str__() repr will call the class attributes __repr__ (not the instance attribute) 1 2 def repr(x): return type(x).__repr__(x) str will call __str__. If no __str__ attribute is found, use repr string Interface A shared message (attribute name) that elicits similar behavior from different object classes is a powerful methos of abstraction An interface is a set of shared messages, along with a specification of what they mean Special Method Names\nCertain names are special because they have built-in behavior. These names always start and end with two underscores 1 2 3 4 5 # 以下几种表述是等价的 # Ratio is a user-defined class Ratio(1, 3) + Ratio(1, 6) Ratio(1, 3).__add__(Ratio(1, 6)) Ratio(1, 6).__radd__(Ratio(1, 3)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Ratio: # ... def __add__(self, other): # type dispatching if isinstance(ohter, float): # type coercion return float(self) + other elif isinstance(other, int): # ... elif isinstance(other, Ratio): # ... __radd__ = __add__ def __float__(self): return self.numer / self.denom isinstance() return whether an object is an instance of a class or of a subclass thereof Lecture 22 Composition Linked Lists\n1 2 3 4 5 6 class Link: empty = () def __init__(self, first, rest=empty): assert rest is Link.empty or isinstance(rest, Link) self.first = first self.rest = rest Linked List Processing\nLinked Lists Mutation\nTree Class\nTree Mutation\nLecture 23 Efficiency Measuring Efficiency\n1 2 3 4 5 6 7 # a decorator that will give call counts using f.call_count def count(f): def counted(n): counted.call_count += 1 return f(n) counted.call_count = 0 return counted Memoization\n1 2 3 4 5 6 7 8 # a decorator def memo(f): cache = {} def memoized(n): if n not in cache: cache[n] = f(n) return cache[n] return memoized Exponentiation\nOrder of Growth Notation\nOrders of Growth\nSpace\nAt any moment there is a set of active environments Memory that is used for other values and frames can be recycled Active environments: Environments for any function calls currently being evaluated Parent environments of functions named in active environments Lecture 24 Decomposition Modular Design\nIsolate different parts of a program that address different concerns Set Intersection\n线性时间查找两个有序列表重叠部分的方法： 设置两个指针 $i,j$ ，分别指向两个列表 $s, t$ 的第一个元素 如果 $s_i \u0026lt; t_j$ ，那么 $s_i$ 一定不与 $t_j$ 及其后面的元素相同（因为有序），所以可以 $i$ 加一 如果 $s_i = t_j$ ，那么找到一对相同元素， $i, j$ 都加一 $i, j$ 中任意一个走到最后，说明另一个剩下的也没得匹配了，结束 小知识点：\nsorted 1 sorted(iterable, /, *, key=None, reverse=False) 如果传入 key，那么会按照 key(x) 的大小给 x 排序\njson 1 2 3 4 import json for line in open(\u0026#39;restaurants.json\u0026#39;): r = json.loads(line) Restaurant(r[\u0026#39;name\u0026#39;], r[\u0026#39;stars\u0026#39;]) Lecture 25 Data Examples Lists\nOperation Desciption Example append() adds one element to a list extend() adds all elements in one list to another list addition \u0026amp; slicing create new lists containing existing elements list() creates a new list containing existing elements slice assignment replaces a slice with new values (or remove elements from a list by assigning [] to a slice) s[0:0] = t, t is a list, it will replace s[0:0] with t**\u0026rsquo;s elements** pop() removes and returns the last element remove() removes the first element equal to the argument Objects\nIterables \u0026amp; Iterators\nLinked Lists\n本节是习题课\n","date":"2025-07-24T11:34:11+08:00","image":"https://freeMdoge.github.io/p/cs-61a-%E7%AC%94%E8%AE%B0/fengmian2_hu_77e7423d0079587d.png","permalink":"https://freeMdoge.github.io/p/cs-61a-%E7%AC%94%E8%AE%B0/","title":"CS 61A 笔记"},{"content":"现在我进行一次修改\n还有修改？！？ 修改时区 1 timeZone: \u0026#34;Asia/Shanghai\u0026#34; CST 可以表示表示中国标准时间，也可能表示其他时区，可能产生歧义，于是我不想用这个\n这是一段 C++ 代码 1 2 3 4 5 6 7 8 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int a; cin \u0026gt;\u0026gt; a; cout \u0026lt;\u0026lt; a + a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 现在需要多层目录\u0026hellip; 真的会有吗\n（测试 文章目录折叠和展开）\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n二级！ 我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n三级！ 我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n又是二级 我只是占位置的\n我只是占位置的\n又是三级！ 我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n给力的图标 给力的图标\n引用 hi\nhello\n","date":"2025-07-23T16:56:43+08:00","image":"https://freeMdoge.github.io/p/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2/picture11_hu_11ebbd94cc28f57f.png","permalink":"https://freeMdoge.github.io/p/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2/","title":"这是一个测试页面"}]