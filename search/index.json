[{"content":"CS 61B UCB CS61B SP21\nJava Java 基础 控制台输出\n1 System.out.println(); 数组\n创建 1 2 int[] arr1 = new int[10]; int[] arr2 = new int[] {1, 2, 3}; 长度 1 arr1.length 引用类型\n除了 byte, short, int, long, float, double, boolean, char 以外都是引用类型 引用类型存地址，引用类型之间的赋值只会复制地址，不会拷贝指向的实例。传参的时候传进去的也是地址 == 返回地址是否相同，.equals 由类来定义，返回逻辑上两个对象是否相同 实现 equals() 的同时需要实现 hashCode() 访问修饰符\n类的声明可以嵌套，内部的类起到私有类的作用。对于私有嵌套类，访问修饰符无关紧要。 嵌套的内部类可以声明为静态的，可以节省一定内存，静态嵌套类不能使用外部类的成员变量和方法，静态嵌套类可以实例化 JUnit\n1 2 3 4 5 @Test public void testMethod() { assertEquals(\u0026lt;expected\u0026gt;, \u0026lt;actual\u0026gt;); assertTrue(\u0026#34;A error message\u0026#34;, condition); } 用来进行测试的函数需要加 @Test 并且不能是静态函数 方法重载\n同样的方法名，但是不同的参数（个数/类型/不同类型的顺序） 和返回值类型与访问修饰符无关，可相同可不相同 Java 代码风格规范\nStyle Guide | CS 61B Spring 2021 Java 内置 List\nList 是接口，ArrayList 是它的几个实现之一 1 2 3 4 5 6 7 8 9 10 11 12 import java.util.List; import java.util.ArrayList; public class SimpleBuiltInListExample { public static void main(String[] args) { List\u0026lt;Integer\u0026gt; L = new ArrayList\u0026lt;\u0026gt;(); L.add(5); L.add(10); L.add(15); System.out.println(L); List\u0026lt;Integer\u0026gt; L2 = Utils.readIntsFromFile(“somedata.csv”); } } Java 类型转换\n原始数据类型中，小→大是自动类型转换，大→小是强制类型转换，要写 (目标类型) 引用数据类型中 向上转型：子类对象的引用赋给父类变量，自动发生，安全。 向上转型使得子类对象表现为父类的形态，只能调用父类中声明的方法（但如果子类重写了方法，则调用的是子类重写后的版本）。 向下转型：父类引用强制转换回子类引用，需要强制转换，不安全（可能抛 ClassCastException ） 只有当父类引用实际指向的对象就是目标子类（或目标子类的子类）实例时，向下转型才合法。 Java 泛型\n在定义类时，只需在类名的开头声明一次泛型类型参数 声明并实例化一个使用了泛型的数据结构时，类型信息只需完整写出一次 1 2 3 public class DLList\u0026lt;T\u0026gt; { ... } // 声明中写 Double，但是实例化中不用写： DLList\u0026lt;Double\u0026gt; s1 = new DLList\u0026lt;\u0026gt;(); 使用包装类而不是基本类型： 基本类型 包装类 int Integer char Character boolean Boolean double Double long Long short Short byte Byte float Float Java 高阶函数\nJava 7 或更早：用接口实现（仍在广泛使用） Java 8 之后： 1 2 3 4 5 6 7 8 9 10 11 12 public class Java8HoFDemo { public static int tenX(int x) { return 10*x; } public static int doTwice(Function\u0026lt;Integer, Integer\u0026gt; f, int x) { return f.apply(f.apply(x)); } public static void main(String[] args) { int result = doTwice(Java8HoFDemo::tenX, 2); System.out.println(result); } } Java 继承 方法重写：子类中有一个和父类中签名相同的一个方法 @Override ：标上这个之后，不是方法重写会过不了编译，可以防止方法名拼写错误，并且易于表示该方法是在更高层级定义的 子类必须重写实现的接口中所有的方法 父类变量可以存子类对象的地址，但是子类变量不能存父类变量的地址 1 2 3 4 5 6 7 public class MyClass\u0026lt;T\u0026gt; implements MyInterface { ... @Override public void myMethod() { ... } } 默认方法：子类会继承父类中该方法的实现，子类也可以重写该方法 1 2 3 4 5 6 public interface MyInterface { ... default public void defaultMethod() { ... } } 静态类型（编译时类型）：声明时指定的类型 动态类型（运行时类型）：实际引用的类型 动态方法选择：当通过父类（静态类型）引用调用一个被重写的方法时，Java 虚拟机 (JVM) 会在运行时根据对象的动态类型来决定到底执行哪个版本的（子类的）方法。 编译时，根据静态类型确定方法的签名 运行时，对象的动态类型执行该签名的方法 用 extends 来继承一个类 1 2 3 4 5 6 public class RotatingSLList\u0026lt;Blorp\u0026gt; extends SLList\u0026lt;Blorp\u0026gt;{ public void rotateRight() { Blorp oldBack = removeLast(); addFirst(oldBack); } } 通过 super 关键字来调用父类被重写的方法或访问父类的成员变量，也可以通过 super() 调用父类的构造方法 构造方法不会被继承，但是子类的构造函数首先要调用父类的构造方法，如果子类构造函数没有显式的调用父类构造方法，那么 Java 会自动调用父类的无参构造方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class VengefulSLList\u0026lt;Item\u0026gt; extends SLList\u0026lt;Item\u0026gt; { private SLList\u0026lt;Item\u0026gt; deletedItems; public VengefulSLList() { super(); // must come first! deletedItems = new SLList\u0026lt;Item\u0026gt;(); } @Override public Item removeLast() { Item oldBack = super.removeLast(); deletedItems.addLast(oldBack); return oldBack; } } Data Structure 线性数据结构\n名称 数据结构 AList 可变长数组 SLList 单向链表 ","date":"2025-11-08T15:19:21+08:00","image":"https://freeMdoge.github.io/p/cs-61b-%E7%AC%94%E8%AE%B0/cover_image_hu_dedfa9cb95740764.jpg","permalink":"https://freeMdoge.github.io/p/cs-61b-%E7%AC%94%E8%AE%B0/","title":"CS 61B 笔记"},{"content":"使用主题：hugo-theme-stack 3.30.0\n参考：\n【Hugo】Stack主题自定义修改\nHugo Stack 魔改美化\n引入点线漂浮动态背景 参考：【Hugo】修改博客背景并引入动态背景\n如果出现背景显示高度问题，在上文给的代码中加上一句：\n1 2 3 4 5 \u0026lt;style\u0026gt; #particles-js { height: 100%; } \u0026lt;/style\u0026gt; 修改代码高亮样式 参考： 深入探究 Hugo 代码高亮\n我是把暗色模式下的高亮改成了 onedark\nstack 主题默认 noClasses: false，它的代码高亮 scss 文件在 assets\\scss\\partials\\highlight 下\n用 hugo gen 得到的 onedark.css 中的内容替换 dark.scss\n行号和代码之间间隔过大：把原来 dark.scss 中的 display: block 等内容补充到替换后的文件中\n代码背景和主题的代码框背景色不同：修改 assets\\scss\\variables.scss 中的 --pre-background-color\n","date":"2025-07-24T20:02:42+08:00","image":"https://freeMdoge.github.io/p/hugo-stack-%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9/image_hu_1d0737c817725247.png","permalink":"https://freeMdoge.github.io/p/hugo-stack-%E4%B8%BB%E9%A2%98%E9%AD%94%E6%94%B9/","title":"Hugo Stack 主题魔改"},{"content":"CS 61A Test the code in HW/Lab use ok:\n1 py ok --local -q \u0026lt;question_name\u0026gt; use ok interactively:\n1 py ok --local -q \u0026lt;question_name\u0026gt; -i use Python\u0026rsquo;s doctest:\n1 py -m doctest \u0026lt;file_name.py\u0026gt; Lecture 01 Welcome Python code consists of expressions and statements\nStatements typically describe actions.\nassignment statement expressions typically describe computations.\na number numbers combined with mathematical operators a compound expression the interperter will evaluate（求值） using infix notation call expression applying a function to some arguments Operator(Operand, Operand) Function notation has three principal advantages over the mathematical convention of infix notation: arbitrary number of arguments a straightforward way to nested expressions simple forms (without square root, superscripts, \u0026hellip;) Python 代码由 expressions 和 statements 两部分组成。statements 用于描述 actions ，比如赋值；expressions 用于描述 computations ，比如数字，计算表达式，函数调用表达式。\n函数表示相较传统的中序表达式，有一系列的优点。\nLecture 02 Functions built-in functions and built-in names\nassignment statement\nname = expression python will evaluate the expression and bind it to the name it\u0026rsquo;s possible to bing mutiple names to values in one single statement assignment statements can also be used to give names to functions Defining Functions\ndef statement \u0026amp; return expression the top line between the def and the colon is called the function signature ( \u0026lt;name\u0026gt; (\u0026lt;formal parameters\u0026gt;) ) the function body is everything that\u0026rsquo;s indented after the first line execution procesure for def statement: create a funtion with signature set the body of that funtion bind \u0026lt;name\u0026gt; to that function in the current frame procedure for calling/applying user-defined funtions (ver 1): Add a local frame, forming a new environment Bind the function\u0026rsquo;s formal parameters to its arguments in that frame execute the body of the funtion in that new environment Environment\nLooking Up Names In Environments An environment is a sequence of frames A name evaluates to the value bound to that name in the earliest frame of the current environment in which that name is found Environment Diagrams Environments are real things. They\u0026rsquo;re the way in which an interpreter for a programming language keeps track of what names mean assignments statements change the bindings between names and values in frames Print and None\nNone indicates that nothing is returned. A funtions that does not explicitly return a value will return None. None is not displayed by the interpreter as the value of an expression Pure Funtions just return values; Non-Pure Functions have side effect 在 Python 中，assignment statements 用于给 names 绑定值。\ndef 语句可以用来定义函数，它包括 function signature 和 function body ，并且 def 语句会将 signature 中的 name 在当前帧上绑定在定义的函数上。调用函数时会建立一个新的 frame，将参数传入新的 frame 中，在里面执行函数的 body 。\nFormal parameter 是形参，argument 是实参\n一系列的 frame 构成 environment，environment 用于确定 name 指代了什么。寻找一个 name 的意义时，会找到最近的出现该 name 的 frame 中的值。\n如果一个函数什么都不返回，那么它会返回 None\nLecture 03 Control Environment\nPython features\noperators 2013 / 10 =\u0026gt; 201.3 (truediv), 2013 // 10 =\u0026gt; 201 (floordiv) from operator import add, mul, truediv, floordiv, mod assignment statement (muliple values) return n // d, n % d q, r = func(2013, 10) documentation and doctest doc string: the first line below the def line in the def statement example interactive session: can be simulated by \u0026ldquo;py -m doctest \u0026lt;filename\u0026gt;\u0026rdquo; \u0026ldquo;py -m doctest -v \u0026lt;filename\u0026gt;\u0026rdquo; will show details default values def func(n, d=10) Conditional Statements\nCompound Statements Clause: Header + indented statements those indented statements are called the Suite of the clause The first header determines a statement\u0026rsquo;s type, the header of a clause \u0026ldquo;controls\u0026rdquo; the suite that follows (eg. def statement) if, elif, else Boolean Contexts False values: False, 0, \u0026lsquo;\u0026rsquo;, None True values: Anything else (True) Iteration\nwhile statements evaluate the header\u0026rsquo;s expression, if true, then execute the suite 代码执行时，会在被执行代码的 environment 中寻找 name 的意义\nPython 有一些特性：运算符、多元素的赋值、doctest、函数参数的默认值\n复合语句总是由一系列 clause 组成，每个 clause 中先是一个 header ，然后是冒号，然后一系列缩进的 statement\nPython 中的 False 可以是 False, 0, 空字符串, None 等，其他值都是 True\nLecture 04 High-Order Functions The Fibonacci Sequnce\nControl\nThe Condition Statements can skip clause, but the Call Expression will evaluate all of the subexpressions Control Expressions\nshort-circuiting and: evaluate the \u0026lt;left\u0026gt; first, if true, then evaluate the \u0026lt;right\u0026gt; or: evaluate the \u0026lt;left\u0026gt; first, if false, then evaluate the \u0026lt;right\u0026gt; Higher-Order Functions\nto generalize patterns by defining functions that take arguments, that give us back the specific instances of those patterns a formal parameter can be bound to a function a function can be the return value Functions defined within other function bodies are bound to names in a local frame a local def statement can refer to names in the enclosing function The Purpose of Higher-Order Functions Functions are first class: Functions can be manipulated as values in Python, meaning they can be passed as arguments, they can be returned as returned values. Higher-order functions: Express general methods of computation, Remove repetition from programs, Separate concerns among functions assert statement assert \u0026lt;boolean expression\u0026gt;, \u0026lt;error message\u0026gt; if the expression evaluates to a false value, then the error message will be printed. 1 2 3 4 5 6 def make_adder(n): \u0026#39;\u0026#39;\u0026#39; A function that returns a function \u0026#39;\u0026#39;\u0026#39; def adder(k): return k + n return adder 前面的 Fibonacci Sequence 和 Control Statements 与 Call Expressions 之间的比较是为了深化对控制语句的理解\nPython 中的 and 和 or 有短路逻辑\nHigher-Order Functions 可以通过定义接收参数的函数来概括模式，从而返回这些模式的具体实例。函数可以作为参数，也可以作为返回值。函数是第一类值\n定义在其他函数之中的函数可以引用它所在函数的 name，内层函数本身会绑定到外层函数所在 local frame 的 name 上\nassert statements 可以用来报错，当它后面的表达式为假时，打印错误信息\nLecture 05 Environments Environments\nEnvironments Enable Higher_Order Functions\nHigher-order function: A function that takes a funtion as an argument value or returns a funtion as a return value\nApplying a user-defined function:\ncreate a new frame bind formal parameters to arguments execute the body Environment Diagrams for Nested Def Statements\nEvery user-defined function has a parent frame (often global) The parent of a function is the frame in which it was defined Every local frame has a parent frame (often global) The parent of a frame is the parent of the function called How to Draw an Environment Diagram\nLocal Names\nLocal Name are not Visible to Other (Non-Nested) Functions Lambda Expressions\nNo \u0026ldquo;return\u0026rdquo; keyword in lambda expressions! must be a single expression (and Lambda expressions in Python cannot contain statements at all) Lambda expressions are not common in Python, but important in general 1 2 3 4 square = lambda x: x * x print(square(10)) print((lambda x: x * x)(9)) Fuction Currying\nTransforming a multi-argument function into a single-argument, higher-order function 对于普通的函数，它在环境图中的 parent 就是 Global（这表示它们是在 Global frame 中被 define 的），而对于嵌套的内层函数，它的 parent 是它的外层函数被调用时创建的 frame（它们是在外层函数所在的 frame 中被 define 的）\nLambda 表达式中只能放 expression ，不能放 statement 。Lambda 表达式和 def 语句会按照相同的行为创建函数（决定函数的 behavior, parent 等），但是 def 语句会给函数一个 intrinsic name 而 Lambda 表达式不会\n柯里化（Currying）是一种处理多元函数的方法。它产生一系列连锁函数，其中每个函数固定部分参数，并返回一个新函数，用于传回其它剩余参数的功能。（转自网络）\nLecture 06 Sounds (Optional) Why do we use higher-order functions\nExample: WAV files Lecture 07 Functional Abstraction Lambda Function Environments\nReturn Statements\ninverse The inverse of a function is to return a g() such that it\u0026rsquo;s the case that f(x) passed into g gives us back x 1 2 3 4 5 6 7 8 9 10 11 def search(f): \u0026#34;\u0026#34;\u0026#34;Return the first positive integer x that makes f(x) equals to True\u0026#34;\u0026#34;\u0026#34; x = 0 while True: if f(x): return x x += 1 def inverse(f): \u0026#34;\u0026#34;\u0026#34;Return g(y) such that g(f(x)) = x.\u0026#34;\u0026#34;\u0026#34; return lambda y: search(lambda x: f(x) == y) Abstraction\nFunction Abstraction Choosing Name Which Values Deserve a Name Repeated compound expressions Meaningful parts of complex expressions Errors \u0026amp; Traceback\nsyntax error, runtime error, logical error traceback inverse 表示反函数\n编写代码有三种 error，其中 runtime error 会有 traceback 可以参考\nLecture 08 Function Examples Decorators\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def trace(fn): \u0026#34;\u0026#34;\u0026#34; Return a function. Why do we use a function to return a function, rather than directly using one function? That is because we need the outer function to receive a parameter, which decide which function the inner function will call In other word, what we need is not a fixed function, but a function that would flexibly call the function we want. So we need a outer function to program the inner function. \u0026#34;\u0026#34;\u0026#34; def traced(x): \u0026#34;\u0026#34;\u0026#34; This function does what you want the decorator to do. Call print before fn, then call fn, then pass what fn returned. What is fn? The outer funtion will told. \u0026#34;\u0026#34;\u0026#34; print(\u0026#39;Calling\u0026#39;, fn, \u0026#39;on argument\u0026#39;, x) return fn(x) return traced @trace def square(x): return x * x # is identical to : # square = trace(square) def sum_squares_up_to(n): k = 1 total = 0 while k \u0026lt;= n: total, k = total + square(k), k + 1 return total 1 2 3 4 5 6 7 8 9 10 def erasefunc(f): def tmp(x, y): return 1 return tmp @erasefunc def square(x): return x * x print(square(10, 9)) decorator 感觉可以理解为外层函数接收需要被装饰的函数 f ，返回的内层函数负责调用 f ，并额外进行一些操作，看作是装饰。\nLecture 09 Recursion Self-Reference\nReturn a function by its own name 1 2 3 4 5 6 7 8 9 10 11 12 13 def print_all(x): print(x) return print_all print_all(1)(3)(5) def print_sums(x): print(x) def next_sum(y): return print_sums(x+y) return next_sum print_sums(1)(3)(5) Recursive Functions\nConditional statements check for base cases Base cases are evaluated without recursive calls Recursive cases are evaluated with recursive calls Mutual Recursion\noccurs when two different functions call each other Recursion and Iteration\nConverting Recursion to Iteration: Figure out what state must be maintained by the iterative funciton Lecture 10 Tree Recursion 本节通过 打印右凸三角阶梯型数字、打印右凹阶梯型数字、求斐波那契数列、解决整数划分问题 来加深对递归的理解。\n整数划分：给定 $n, m$ ，使用不超过 $m$ 的若干可重复正整数相加得到 $n$ ，共有多少种情况？\n分析：两种情况，使用至少一次 $m$，和不使用 $m$，即 $f_{n,m} = f_{n-m,m} + f_{n,m-1}$ ，递归求解\nLecture 11 Sequences Lists\n基本用法 1 2 3 4 odds = [41, 43, 47, 49] odds[2] # odds[2] =\u0026gt; 47 getitem(odds, 0) # getitem(odds, 0) =\u0026gt; odds[0] =\u0026gt; 41 (getitem在operator模块中) len(odds) # len(odds) =\u0026gt; 4 列表的合并和重复 1 2 3 digits = [1, 8, 2, 8] [2, 7] + digits * 2 # =\u0026gt; [2, 7, 1, 8, 2, 8, 1, 8, 2, 8] 列表嵌套 1 myList = [[10, 20], [30, 40]] 查 1 2 3 4 digits = [1, 8, 2, 8] 1 in digits # =\u0026gt; True 5 not in digits # =\u0026gt; True [1, 8] in digits # =\u0026gt; False For Statements\n1 2 for \u0026lt;name\u0026gt; in \u0026lt;expression\u0026gt;: \u0026lt;suite\u0026gt; the header \u0026lt;expression\u0026gt; must yield an iterable value (a sequence) Sequence Unpacking: 1 2 3 pairs = [[1, 2], [2, 2], [3, 2]] for x, y in pairs: # ... Range\nA range is a sequence of consecutive integers 1 2 range(-2, 2) # =\u0026gt; -2, -1, 0, 1 range(4) # =\u0026gt; 0, 1, 2, 3 Convert to a list (List constructor) 1 list(range(-2, 2)) # =\u0026gt; [-2, -1, 0, 1] for _ in range 1 2 for _ in range(3): print(\u0026#39;Go Bears!\u0026#39;) List Comprehensions\n1 2 3 4 5 6 7 8 9 10 letters = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;p\u0026#39;] [letters[i] for i in [3, 4, 6, 8]] # =\u0026gt; [\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;o\u0026#39;] odds = [1, 3, 5, 7, 9] [x+1 for x in odds] # =\u0026gt; [2, 4, 6, 8, 10] [x for x in odds if 25 % x == 0] # =\u0026gt; [1, 5] Lecture 12 Containers Closure Property of Data Types\nThe result of combination can itself be combined using the same method (Lists can contain lists as elements) Slicing\nslicing operator: [:] 1 2 3 4 5 odds = [3, 5, 7, 9, 11] odds[1:3] # =\u0026gt; [5, 7] odds[:3] # =\u0026gt;[3, 5, 7] odds[1:] # =\u0026gt; [5, 7, 9, 11] odds[:] # =\u0026gt; [3, 5, 7, 9, 11] slicing creates new values Processing Container Values\nSequence Aggregation Several built-in functions take iterable arguments and aggregate them into a value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 sum(iterable[, start]) -\u0026gt; value # \u0026#34;iterable\u0026#34; can be a list # \u0026#34;[]\u0026#34; means optional # return the sum of an iterable of numbers plus the value of parameter \u0026#39;start\u0026#39; (the default value of \u0026#39;start\u0026#39; is 0, which means if the members of \u0026#39;iterable\u0026#39; are lists, you need to explicitly provide that \u0026#39;start\u0026#39; is \u0026#39;[]\u0026#39; (empty list), or it will throw an error) # if you sum a list of lists, you get a list containing the elements of those lists. # sum([ [1], [2, 3], [4] ], []) =\u0026gt; [1, 2, 3, 4] # sum([ [[1]], [2] ], []) =\u0026gt; [[1], 2] max(iterable[, key=func]) -\u0026gt; value max(a, b, c, ...[, key=func]) -\u0026gt; value # return the largest argument # key function: applies a function to every element and computes the maximum based on the return values (notice: the return value of max() is x, not f(x)!) min() all(iterable) -\u0026gt; bool # Return True if bool(x) if True for all values x in the iterable. # If the iterable is empty, return True any() Strings\n1 2 3 4 5 6 \u0026#39;nihao\u0026#39; # 这样表示的字符串中不能有单引号 \u0026#34;nihao\u0026#34; \u0026#34;\u0026#34;\u0026#34; multiple lins string the second line \u0026#34;\u0026#34;\u0026#34; # 三引号的字符串可以写多行 \u0026#39;line1\\nline2\u0026#39; # \\n 换行 1 2 3 4 city = \u0026#39;Berkeley\u0026#39; len(city) # =\u0026gt; 8 city[3] # =\u0026gt; \u0026#39;k\u0026#39; (returns a string) \u0026#39;here\u0026#39; in \u0026#34;where\u0026#39;s Waldo?\u0026#34; # =\u0026gt; True Dictionaries\n1 2 3 4 5 6 {} # empty dictionary numerals = {\u0026#39;I\u0026#39;: 1, \u0026#39;V\u0026#39;: 5, \u0026#39;X\u0026#39;: 10} numerals[\u0026#39;X\u0026#39;] # =\u0026gt; 10 list(numerals) # =\u0026gt; [\u0026#39;I\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;X\u0026#39;] numerals.values() # =\u0026gt; dict_values([1, 5, 10]) list(numerals.values()) # =\u0026gt; [1, 5, 10] A key of a dictionary cannot be a list or a dictionary (or any mutable type) Dictionary Comprehension 1 {\u0026lt;key exp\u0026gt;: \u0026lt;value exp\u0026gt; for \u0026lt;name\u0026gt; in \u0026lt;iter exp\u0026gt; if \u0026lt;filter exp\u0026gt;} 1 {x * x: x for x in [1, 2, 3, 4, 5] if x \u0026gt; 2} # =\u0026gt; {9: 3, 16: 4, 25: 5} Lecture 13 Data Abstraction Data Abstraction: Rational Numbers\nconstructor selector Abstraction Barriers\nPair\n1 2 pair = [1, 2] x, y = pair # x = 1, y = 2 Data Representations\n主要讲数据封装抽象的思想\nLecture 14 Trees Tree Abstraction\nRecursive description A tree has a root label and a list of branched Each branch is a tree A tree with zero branches is called a leaf Relative description Each location in a tree is called a node Each node has a label that can be any value One node can be the parent/child of another Implementing the Tree Abstraction\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def tree(label, branches = []): for branch in branches: assert is_tree(branch), \u0026#39;branched must be trees\u0026#39; return [label] + list(branches) def label(tree): return tree[0] def branches(tree): return tree[1:] def is_tree(tree): if type(tree) != list or len(tree) \u0026lt; 1: return False for branch in branches(tree): if not is_tree(branch): return False return True def is_leaf(tree): return not branches(tree) def count_leaves(t): if is_leaf(t): return 1 else: branch_counts = [count_leaves(b) for b in branches(t)] return sum(branch_counts) def leaves(tree): if is_leaf(tree): return [label(tree)] else: return sum(leaves(b) for b in branches(tree)) def increment_leaves(t): if is_leaf(t): return tree(label(t) + 1) else: bs = [increment_leaves(b) for b in branches(t)] return tree(label(t), bs) def increment(t): return tree(label(t) + 1, [increment(b) for b in branches(t)]) Lecture 15 Mutability Object\nA type of object is called a class; classes are first-class values in Python Object-oriented programming: A metaphor for organizing large programs Special syntax that can improve the composition of programs In Python, every value is an object All objects have attributes A lot of data manipulation happens through object methods String (example)\nRepresenting ASCII Unicode Mutation Operations\nmutation is a word that\u0026rsquo;s used whenever there\u0026rsquo;s a change to an object All names that refer to the same object are affected by a mutation Only objects of mutable types can change: lists \u0026amp; dictionaries Tuples\nAnything separated by commas is evaluated as a tuple A lot of people always put the parentheses around them just to be clear about what\u0026rsquo;s going on 1 2 3 4 5 6 3, 4, 5, 6 # =\u0026gt; (3, 4, 5, 6) () # empty tuple tuple([3, 4, 5]) # =\u0026gt; (3, 4, 5) 2, # =\u0026gt; (2,) (a tuple with only one element) (3, 4) + (5, 6) # =\u0026gt; (3, 4, 5, 6) 5 in (3, 4, 5) # =\u0026gt; True Tuples are immutable values that means it is possible to use them as the keys in a dictionary (it is not allowed to use a list as a key in a dictionary or you will get the error \u0026ldquo;unhashable type list\u0026rdquo;) Immutable values are protected from mutation A immutable sequence may still change if it contains a mutable value as an element Mutation\nIdentity Operators Identity: \u0026lt;exp0\u0026gt; is \u0026lt;exp1\u0026gt; evaluates to True if both \u0026lt;exp0\u0026gt; and \u0026lt;exp1\u0026gt; evaluate to the same object Equality: \u0026lt;exp0\u0026gt; == \u0026lt;exp1\u0026gt; evaluates to True if both \u0026lt;exp0\u0026gt; and \u0026lt;exp1\u0026gt; evaluate to equal values Identical objects are always equal values, but not the other way around A default argument value is part of a function value, not generated by a call Mutable Functions\n实现函数中持久存储数据：在外层函数中用列表存要存储的数据，在内层函数实现修改，然后返回内层函数\nLecture 16 Iterators Iterators\nA container can provide an iterator that provides access to its elements in some order built-in function: iter(iterable) Return an iterator over the elements of an iterable value built-in function: next(iterator) Return the next element in an iterator The iterator will move advanced at the same time An iterable value is any value that can be passed to iter to produce an iterator An iterator value is returned from iter and can be passed to next; all iterators are mutable 1 2 3 4 5 s = [[1, 2], 3, 4, 5] t = iter(s) next(t) # =\u0026gt; [1, 2] next(t) # =\u0026gt; 3 list(t) # =\u0026gt; [4, 5] Dictionary Iteration\nThe order of items in a dictionary is the order in which they were added (starting at Python 3.6. In older versions, items in a dictionary appeared in an arbitrary order) 1 2 3 4 d = {\u0026#39;o\u0026#39;: 1, \u0026#39;t\u0026#39;: 2} k = iter(d.keys()) v = iter(d.values()) i = iter(d.items()) If the dictionary changes size, then we can\u0026rsquo;t use any of the iterators we\u0026rsquo;ve constructed For Statements\n1 2 3 4 5 6 7 r = range(3, 6) ri = iter(r) next(ri) for i in ri: print(i) # =\u0026gt; 4 \\n 5 for i in ri: print(i) # =\u0026gt; nothing, because we\u0026#39;re already at the end of ri Built-In Iterator Functions\nMany built-in Python sequence operations return iterators that compute results lazily (lazily computation: only computed when it has been requested)\nmap(func, iterable) Iterate over func(x) for x in iterable\napplies the func to each element in the iterable instead of applying it immediately, it returns and iterator, which iterates over the values func(x) for every x in the iterable filter(func, iterable) Iterate over x in iterable if func(x)\nzip(first_iter, second_iter) Iterate over co-indexed (x, y) pairs\nreversed(sequence) Iterate over x in a sequence in reverse order\nTo view the contents of an iterator, place the resulting elements into a container\nlist(iterable) tuple(iterable) sorted(iterable) Created a sorted list Zip\n1 2 3 4 5 6 7 8 9 10 11 # returns an iterator over co-indexed tuples list(zip([1, 2], [3, 4])) # =\u0026gt; [(1, 3), (2, 4)] # if one iterable is longer than the other, zip only iterates over matches and skips extras list(zip([1, 2], [3, 4, 5])) # =\u0026gt; [(1, 3), (2, 4)] # more than two iterables can be passed to zip list(zip([1, 2], [3, 4, 5], [6, 7])) # =\u0026gt; [(1, 3, 6), (2, 4, 7)] Using Iterators\nReasons for Using Iterators Code that processes and iterator or iterable makes few assumptions about the data itself that means Changing the data representation from a list to a tuple,map object, or dict_keys doesn\u0026rsquo;t require rewriting code. An iterator bundles together a sequence and a position within that sequence as one object Lecture 17 Generators Generators\nA generator function is a function that yields values instead of returning them A normal function returns once; a generator function can yield multiple times A generator is an iterator created automatically by calling a generator function When a generator function is called, it returns a generator that iterates over its yields Generators \u0026amp; Iterators\nA yield from statement yields all values from an iterator or iterable (Python 3.3) 1 2 3 4 5 6 7 8 9 10 def a_then_b_1(a, b): for x in a: yield x for x in b: yield x def a_then_b_2(a, b): yield from a yield from b # a_then_b_1 and a_then_b_2 are completely equivalent If you\u0026rsquo;re ever writing a program there there are many possibilities and you only want a few of them, sometimes this generator function approach can not only be easier to write, easier to read, but also deamatically faster to run Lecture 18 Objects Object-Oriented Programming\nClass Statements\n1 2 3 4 5 6 7 8 9 10 class Account: # __init__ is a special method name for the function that constructs an Accoount instance def __init__(self, account_holder): self.balance = 0 self.holder = account_holder # self is the instance of the Account class on which deposit() was invoked: a.deposit(10) def deposit(self, amount): self.balance = self.balance + amount return self.balance Creating Instances\nthe __init__ method is sometimes called a constructor Instance Attributes An object\u0026rsquo;s attributes are accessed and modified using dot expressions Any attribute can be assigned any value it\u0026rsquo;s OK to introduce a new attribute that wasn\u0026rsquo;t named before. A new attribute can be added at any time in Python Methods\nAll invoke methods have access to the object via the self parameter, and so they can all sccess and manipulate the object\u0026rsquo;s attributes the dot notation automatically supplies the first argument (self) Lecture 19 Attributes Class Attributes\nAssignment \u0026amp; def statements in the suite of class statement create attributes of the class 1 2 3 4 5 6 7 class Clown: nose = \u0026#39;big and red\u0026#39; def dance(): return \u0026#39;No thanks\u0026#39; Clown.nose # =\u0026gt; \u0026#39;big and red\u0026#39; Clown.dance() # =\u0026gt; \u0026#39;No thanks\u0026#39; 1 2 3 4 5 class Account: interest = 0.02 tom_account = Account() tom_account.interest # =\u0026gt; 0.02 Attribute Lookup\nWhen evaluete a dot expression, the name will be matched against the instance attributes of that object, then the class attribute value getattr(instance, attribute_name) look up an attribute using a string (attribute_name) hasattr(instance, attribute_name) whether an attribute of this name exists Attribute Assignment\nif the object is an instance, then assignment sets an instance attribute if the object is a class, then assignment sets a class attribute 1 2 3 4 5 6 7 class Account: interest = 0.02 tom_account = Account() # this is attribute assignment that adds the attribute named interest to the Tom account, not modifies the attribute in Account class: tom_account.interest = 0.08 Method Calls\nBound Methods\nObject + Function = Bound Method 1 2 3 # there are two different ways to call method: Account.deposit(tom_account, 1001) tom_account.deposit(1007) Lecture 20 Inheritance Inheritance\n1 2 class \u0026lt;name\u0026gt;(\u0026lt;base class\u0026gt;): \u0026lt;suite\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Account: interest = 0.02 def __init__(self, account_holder): self.balance = 0 self.holder = account_holder def deposit(self, amount): self.balance = self.balance + amount return self.balance def withdraw(self, amount): if amount \u0026gt; self.balance: return \u0026#39;Insufficient funds\u0026#39; self.balance = self.balance - amount return self.balance class CheckingAccount(Account): withdraw_fee = 1 interest = 0.01 def withdraw(self, amount): return Account.withdraw(self, amount + self.withdraw_fee) Looking up attribute names on classes if it names an attribute in the class, return the attribute value otherwise, look up the name in the base class, if there is one Object-Oriented Design\nDesigning for Inheritance Inheritance and Composition Inheritance: \u0026ldquo;is a\u0026rdquo;, Composition: \u0026ldquo;has a\u0026rdquo; Multiple Inheritance\n1 2 class AsSeenOnTVAccount(CheckingAccount, SavingsAccount): # ... Lecture 21 Representation String Representations\nIn Python, all objects produce two string representations The str is legible to humans The repr is legible to the Python interpreter The str and repr strings are often the same, but not always repr(object) return the canonical string representation of the object. For most object types, eval(repr(object)) == object The result of calling repr on a value is what Python prints in an interactive session Some objects do not have a simple Python-readable string 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; 12e12 12000000000000.0 \u0026gt;\u0026gt;\u0026gt; repr(min) \u0026#39;\u0026lt;built-in function min\u0026gt;\u0026#39; # do not have a simple Python-readable string The result of calling str on the value of an expression is what Python prints using the print function 1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; from fractions import Fraction \u0026gt;\u0026gt;\u0026gt; half = Fraction(1, 2) \u0026gt;\u0026gt;\u0026gt; repr(half) \u0026#39;Fraction(1, 2)\u0026#39; \u0026gt;\u0026gt;\u0026gt; str(half) \u0026#39;1/2\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(half) 1/2 \u0026gt;\u0026gt;\u0026gt; eval(repr(half)) Fraction(1, 2) \u0026gt;\u0026gt;\u0026gt; eval(str(half)) 0.5 F-Strings\nString interpolation involves evaluating a string literal that contains expressions The result of evaluating an f-string literal contains the str string of the value of each sub-expression. Sub-expressions are evaluated in the current environment 1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; f\u0026#39;2 + 2 = {abs(2 + 2)}\u0026#39; \u0026#39;2 + 2 = 4\u0026#39; \u0026gt;\u0026gt;\u0026gt; s = [9, 8, 7] \u0026gt;\u0026gt;\u0026gt; f\u0026#39;{s.pop()} {s.pop()} {s}.\u0026#39; \u0026#39;7 8 [9]\u0026#39; 1 \u0026#39;Ratio({0}, {1})\u0026#39;.format(numer, denom) Polymorphic Function\nstr and repr are both polymorphic; they apply to any object repr invokes a zero-argument method __repr__ on its argument str invokes a zero-argument method __str__ on its argument 1 str(half) == half.__str__() repr will call the class attributes __repr__ (not the instance attribute) 1 2 def repr(x): return type(x).__repr__(x) str will call __str__. If no __str__ attribute is found, use repr string Interface A shared message (attribute name) that elicits similar behavior from different object classes is a powerful methos of abstraction An interface is a set of shared messages, along with a specification of what they mean Special Method Names\nCertain names are special because they have built-in behavior. These names always start and end with two underscores 1 2 3 4 5 # 以下几种表述是等价的 # Ratio is a user-defined class Ratio(1, 3) + Ratio(1, 6) Ratio(1, 3).__add__(Ratio(1, 6)) Ratio(1, 6).__radd__(Ratio(1, 3)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Ratio: # ... def __add__(self, other): # type dispatching if isinstance(ohter, float): # type coercion return float(self) + other elif isinstance(other, int): # ... elif isinstance(other, Ratio): # ... __radd__ = __add__ def __float__(self): return self.numer / self.denom isinstance() return whether an object is an instance of a class or of a subclass thereof Lecture 22 Composition Linked Lists\n1 2 3 4 5 6 class Link: empty = () def __init__(self, first, rest=empty): assert rest is Link.empty or isinstance(rest, Link) self.first = first self.rest = rest Linked List Processing\nLinked Lists Mutation\nTree Class\nTree Mutation\nLecture 23 Efficiency Measuring Efficiency\n1 2 3 4 5 6 7 # a decorator that will give call counts using f.call_count def count(f): def counted(n): counted.call_count += 1 return f(n) counted.call_count = 0 return counted Memoization\n1 2 3 4 5 6 7 8 # a decorator def memo(f): cache = {} def memoized(n): if n not in cache: cache[n] = f(n) return cache[n] return memoized Exponentiation\nOrder of Growth Notation\nOrders of Growth\nSpace\nAt any moment there is a set of active environments Memory that is used for other values and frames can be recycled Active environments: Environments for any function calls currently being evaluated Parent environments of functions named in active environments Lecture 24 Decomposition Modular Design\nIsolate different parts of a program that address different concerns Set Intersection\n线性时间查找两个有序列表重叠部分的方法： 设置两个指针 $i,j$ ，分别指向两个列表 $s, t$ 的第一个元素 如果 $s_i \u0026lt; t_j$ ，那么 $s_i$ 一定不与 $t_j$ 及其后面的元素相同（因为有序），所以可以 $i$ 加一 如果 $s_i = t_j$ ，那么找到一对相同元素， $i, j$ 都加一 $i, j$ 中任意一个走到最后，说明另一个剩下的也没得匹配了，结束 小知识点：\nsorted 1 sorted(iterable, /, *, key=None, reverse=False) 如果传入 key，那么会按照 key(x) 的大小给 x 排序\njson 1 2 3 4 import json for line in open(\u0026#39;restaurants.json\u0026#39;): r = json.loads(line) Restaurant(r[\u0026#39;name\u0026#39;], r[\u0026#39;stars\u0026#39;]) Lecture 25 Data Examples Lists\nOperation Desciption Example append() adds one element to a list extend() adds all elements in one list to another list addition \u0026amp; slicing create new lists containing existing elements list() creates a new list containing existing elements slice assignment replaces a slice with new values (or remove elements from a list by assigning [] to a slice) s[0:0] = t, t is a list, it will replace s[0:0] with t**\u0026rsquo;s elements** pop() removes and returns the last element remove() removes the first element equal to the argument Objects\nIterables \u0026amp; Iterators\nLinked Lists\n本节是习题课\nLecture 28 Scheme Scheme Fundamentals\nScheme programs consist of expressions: Primitive expressions \u0026amp; Combinations numbers are self-evaluating; symbols are bound to values Call expressions include an operator and 0 or more operands in parentheses quotient names Scheme\u0026rsquo;s built-in integer division procedure (i.e., \u0026ldquo;function\u0026rdquo; in Python) Combinations can span multiple lines 1 2 3 4 5 6 7 8 9 10 11 12 scm\u0026gt; (+ 1 2 3 4) 10 scm\u0026gt; (- (* 2 2) 1) 3 scm\u0026gt; (number? 3) #t scm\u0026gt; (number? +) #f scm\u0026gt; (zero? 0) #t scm\u0026gt; (integer? 2.2) #f Special Forms\nA combination that is not a call expression is a special form (if \u0026lt;predicate\u0026gt; \u0026lt;consequent\u0026gt; \u0026lt;alternative\u0026gt;) (and \u0026lt;e1\u0026gt; ... \u0026lt;en\u0026gt;) (or \u0026lt;e1\u0026gt; ... \u0026lt;en\u0026gt;) binding symbols: (define \u0026lt;symbol\u0026gt; \u0026lt;expression\u0026gt;) define new precedures: (define (\u0026lt;symbol\u0026gt; \u0026lt;formal parameters\u0026gt;) \u0026lt;body\u0026gt;) 1 2 (define (average x y) (/ (+ x y) 2)) Lambda Expressions\nLambda expressions evaluate to anonymous procedures (lambda (\u0026lt;formal-paremeters\u0026gt;) \u0026lt;body\u0026gt;) 1 2 3 4 (define (plus4 x) (+ x 4)) (define plus4 (lambda (x) (+ x 4))) ((lambda (x y z) (+ x y (square z))) 1 2 3) More Special Forms\ncond (condition): The cond special form that behaves like if-elif-else statements in Python (else is optional) 1 2 3 4 5 6 7 8 (cond ((\u0026gt; x 10) (print \u0026#39;big)) ((\u0026gt; x 5) (print \u0026#39;medium)) (else (print \u0026#39;small))) (print (cond ((\u0026gt; x 10) \u0026#39;big) ((\u0026gt; x 5) \u0026#39;medium) (else \u0026#39;small))) begin: The begin special form combines multiple expressions into one expression there\u0026rsquo;s only space in Scheme for one expression, and begin expression allows you to put as many thing as you want as sub-expressions, and they\u0026rsquo;ll all get evaluated. 1 2 (cond ((\u0026gt; x 10) (begin (print \u0026#39;big) (print \u0026#39;guy))) (else (begin (print \u0026#39;small) (print \u0026#39;fry)))) let: The let special form binds symbols to values temporarily; just for one expression 1 2 3 (define x (let ((a 3) (b (+ 2 2))) (sqrt (+ (* a a) (* b b))))) Lecture 29 Scheme Lists Scheme Lists\n(linked lists) cons: Two-argument procedure that creates a linked list car: Procedure that returns the first element of a list cdr: Procedure that returns the rest of a list nil: The empty list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026gt; (cons 1 (cons 2 nil)) (1 2) \u0026gt; (define x (cons 1 (cons 2 nil))) \u0026gt; x (1 2) \u0026gt; (car x) 1 \u0026gt; (cdr x) (2) \u0026gt; (list? x) #t \u0026gt; (list? nil) #t \u0026gt; (null? nil) #t \u0026gt; (null? x) #f \u0026gt; (list 1 2 3 4) (1 2 3 4) Symbolic Programming\nQuotation is used to refer to symbols directly in Lisp Special form to indicate that the expression itself is the value quote a = 'a 1 2 3 4 5 6 7 8 \u0026gt; (define a 1) \u0026gt; (define b 2) \u0026gt; (list a b) (1 2) \u0026gt; (list \u0026#39;a \u0026#39;b) (a b) \u0026gt; (list \u0026#39;a b) (a 2) Quotation can also be applied to combinations to form lists 1 2 \u0026gt; \u0026#39;(a b c) (a b c) List processing\n(append s t): list the elements of s and t; append can be called on more then 2 lists (map f s): call a procedure f on each element of a list s and list the results (filter f s): call a procedure f on each element of a list s and list the elements for which a true value is the result (apply f s): call a procedure f with the elements of a list as its arguments 1 2 3 4 \u0026gt; (apply + \u0026#39;(1 2 3 4)) 10 \u0026gt; (+ 1 2 3 4) 10 Lecture 30 Calculator Exceptions\nRaise Statements Python: raise \u0026lt;expression\u0026gt; - \u0026lt;expression\u0026gt; must evaluate to a subclass of BaseException or an instance of one (E.g., TypeError('Bad argument!')) TypeError \u0026ndash; A function was passed the wrong number/type of argument NameError \u0026ndash; A name wasn\u0026rsquo;t found KeyError \u0026ndash; A key wasn\u0026rsquo;t found in a dictionary RecursionError \u0026ndash; Too many recursive calls Try Statements Exception handling can prevent a program from terminating 1 2 3 4 5 try: \u0026lt;try suite\u0026gt; except \u0026lt;exception class\u0026gt; as \u0026lt;name\u0026gt;: \u0026lt;except suite\u0026gt; ... 1 2 3 4 5 try: x = 1 / 0 except ZeroDivisionError as e: print(\u0026#39;handling a\u0026#39;, type(e)) x = 0 Programming Languages\nAn Interpreter is a program that takes as input the code written in a programming language and executes that code in order to create the behavior described by the program A programming language has: Syntax \u0026amp; Semantics To create a new programming language, you either need a: Specification or Canonical Implementation Parsing\nA parser takes text and returns an expression Syntactic analysis identifies the hierarchical structure of an expression, which may be nested Scheme-Syntax Calculator\nA Scheme-Syntax Calculator is a scheme interpreter that does not support mant features of Scheme, but does include the arithmetic operators of Scheme Evaluation\nThe eval function compotes the calue of an expression, which is always a number. It is a generic function that dispatches on the type of the expression (primitive of call) Interactive Interpreters\nRead-Eval-Print Loop Lecture 31 Interpreters Special Forms\nIn the evaluation of a scheme expression, we need to know what sort of expression it is. Calculator just divided expressions into numbers and call expressions, but in scheme there are some other alternatives as well. The scheme_eval function dispatches on expression form: Symbols are bound to values in the current environment Self-evaluating expressions are returned. All other legal expressions atr represented as Scheme lists, called combinations. Quatation\nThe quote special form evaluates to the quoted expression, thich is not evaluated The \u0026lt;expression\u0026gt; itself is the value of the expression '\u0026lt;expression\u0026gt; is shorthand for (quote \u0026lt;expression\u0026gt;) The scheme_read parser converts shorthand to a combination Logical Forms\nLogical forms may only evaluate some sub-expressions Lambda Expressions\nLambda expressions evaluate to user-defined precedures Frames and Environments A frame represents an environment by having a parent frame. Dynamic Scope\nThe way in which names are looked up in Scheme and Python is called lexical scope (or static scope) Lexical scope : The parent of a frame is the environment in which a precedure was defined. Dynamic scope : The parent of a frame is the environment in which a procedure was called. Interpreting Scheme\nThe Structure of an Interpreter Define Expressions\nDefine binds a symbol to a value in the first frame of the current environment Procedure definition is shorthand of define with a lambda expression (define (\u0026lt;name\u0026gt; \u0026lt;formal parameters\u0026gt;) (\u0026lt;body\u0026gt;)) (define \u0026lt;name\u0026gt; (lambda (\u0026lt;formal parameters\u0026gt;) \u0026lt;body\u0026gt;)) To apply a user-defined procedure, create a new frame in which formal parameters are bound to argumant valurs, whose parent is the env of the procedure ","date":"2025-07-24T11:34:11+08:00","image":"https://freeMdoge.github.io/p/cs-61a-%E7%AC%94%E8%AE%B0/fengmian2_hu_77e7423d0079587d.png","permalink":"https://freeMdoge.github.io/p/cs-61a-%E7%AC%94%E8%AE%B0/","title":"CS 61A 笔记"},{"content":"现在我进行一次修改\n还有修改？！？ 修改时区 1 timeZone: \u0026#34;Asia/Shanghai\u0026#34; CST 可以表示表示中国标准时间，也可能表示其他时区，可能产生歧义，于是我不想用这个\n这是一段 C++ 代码 代码块测试：\n单行未指定代码语言\n1 No code language specified 多行未指定代码语言\n1 2 No code language specified No code language specified 多代码块\n1 No code language specified 1 No code language specified 1 2 No code language specified No code language specified 1 2 No code language specified No code language specified 1 2 No code language specified No code language specified 1 2 3 No code language specified No code language specified No code language specified 单行C++\n1 vector\u0026lt;int\u0026gt; v(10, 2); 多行C++\n1 2 3 4 5 6 7 8 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { int a; cin \u0026gt;\u0026gt; a; cout \u0026lt;\u0026lt; a + a \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } 超多行代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* Line */ .chroma .line { display:flex; } /* Keyword */ .chroma .k { color:#c678dd } /* KeywordConstant */ .chroma .kc { color:#e5c07b } /* KeywordDeclaration */ .chroma .kd { color:#c678dd } /* KeywordNamespace */ .chroma .kn { color:#c678dd } /* KeywordPseudo */ .chroma .kp { color:#c678dd } /* KeywordReserved */ .chroma .kr { color:#c678dd } /* KeywordType */ .chroma .kt { color:#e5c07b } /* Name */ .chroma .n { color:#e06c75 } /* NameAttribute */ .chroma .na { color:#e06c75 } /* NameClass */ .chroma .nc { color:#e5c07b } /* NameConstant */ .chroma .no { color:#e06c75 } /* NameDecorator */ .chroma .nd { color:#61afef } /* NameEntity */ .chroma .ni { color:#e06c75 } /* NameException */ .chroma .ne { color:#e06c75 } /* NameLabel */ .chroma .nl { color:#e06c75 } /* NameNamespace */ .chroma .nn { color:#e06c75 } /* NameOther */ .chroma .nx { color:#e06c75 } /* NameProperty */ .chroma .py { color:#e06c75 } /* NameTag */ .chroma .nt { color:#e06c75 } /* NameBuiltin */ .chroma .nb { color:#e5c07b } /* NameBuiltinPseudo */ .chroma .bp { color:#e5c07b } /* NameVariable */ .chroma .nv { color:#e06c75 } /* NameVariableClass */ .chroma .vc { color:#e06c75 } /* NameVariableGlobal */ .chroma .vg { color:#e06c75 } /* NameVariableInstance */ .chroma .vi { color:#e06c75 } /* NameVariableMagic */ .chroma .vm { color:#e06c75 } /* NameFunction */ .chroma .nf { color:#61afef;font-weight:bold } /* NameFunctionMagic */ .chroma .fm { color:#56b6c2;font-weight:bold } 超长代码\n1 2 3 Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. 现在需要多层目录\u0026hellip; 真的会有吗\n（测试 文章目录折叠和展开）\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n二级！ 我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n三级！ 我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n又是二级 我只是占位置的\n我只是占位置的\n又是三级！ 我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n我只是占位置的\n给力的图标 给力的图标\n引用 hi\nhello\n文本 Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nLorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n","date":"2025-07-23T16:56:43+08:00","image":"https://freeMdoge.github.io/p/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2/picture11_hu_11ebbd94cc28f57f.png","permalink":"https://freeMdoge.github.io/p/%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2/","title":"这是一个测试页面"}]